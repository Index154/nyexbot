const {
  MessageActionRow,
  Message,
  MessageEmbed,
  MessageButton,
} = require("discord.js");

/**
 * Creates a pagination embed
 * @param {Message} msg
 * @param {MessageEmbed[]} pages
 * @param {MessageButton[]} buttonList
 * @param {number} timeout
 * @returns
 */
const paginationEmbed = async (msg, embedTemplate, pages, buttonList, timeout = 120000) => {
  if (!msg && !msg.channel) throw new Error("Channel is inaccessible.");
  if (!pages) throw new Error("Pages are not given.");
  if (!buttonList) throw new Error("Buttons are not given.");
  if (buttonList[0].style === "LINK" || buttonList[1].style === "LINK")
    throw new Error(
      "Link buttons are not supported with discordjs-button-pagination"
    );
  if (buttonList.length !== 2) throw new Error("Need two buttons.");

  let page = 0;

  const row = new MessageActionRow().addComponents(buttonList);
  var curPage = "";
  if(pages.length == 1){
	embedTemplate.fields[embedTemplate.fields.length - 1].value = pages[page];
	curPage = await msg.reply({
	  embeds: [embedTemplate.setFooter(`Page ${page + 1} / ${pages.length}`)],
	  allowedMentions: { repliedUser: false },
	  fetchReply: true,
	});
  }else{
	embedTemplate.fields[embedTemplate.fields.length - 1].value = pages[page];
    curPage = await msg.reply({
      embeds: [embedTemplate.setFooter(`Page ${page + 1} / ${pages.length}`)],
      components: [row],
	  allowedMentions: { repliedUser: false },
	  fetchReply: true,
    });

    const filter = (i) =>
      i.customId === buttonList[0].customId ||
      i.customId === buttonList[1].customId &&
	  i.member.user.id === msg.member.user.id;

    const collector = await curPage.createMessageComponentCollector({
      filter,
      time: timeout,
    });

    collector.on("collect", async (i) => {
      switch (i.customId) {
        case buttonList[0].customId:
          page = page > 0 ? --page : pages.length - 1;
          break;
        case buttonList[1].customId:
          page = page + 1 < pages.length ? ++page : 0;
          break;
        default:
          break;
      }
      await i.deferUpdate();
	  embedTemplate.fields[embedTemplate.fields.length - 1].value = pages[page];
      await i.editReply({
        embeds: [embedTemplate.setFooter(`Page ${page + 1} / ${pages.length}`)],
        components: [row],
      });
      collector.resetTimer();
    });

    collector.on("end", () => {
      if (!curPage.deleted) {
        const disabledRow = new MessageActionRow().addComponents(
          buttonList[0].setDisabled(true),
          buttonList[1].setDisabled(true)
        );
        curPage.edit({
          embeds: [embedTemplate.setFooter(`Page ${page + 1} / ${pages.length}`)],
          components: [disabledRow],
        });
      }
    });

  }

  return curPage;
};

const paginationEmbedAlt = async (msg, pages, buttonList, startingId, timeout = 120000, extraButtons) => {
  if (!msg && !msg.channel) throw new Error("Channel is inaccessible.");
  if (!pages) throw new Error("Pages are not given.");
  if (!buttonList) throw new Error("Buttons are not given.");
  if (buttonList[0].style === "LINK" || buttonList[1].style === "LINK")
    throw new Error(
      "Link buttons are not supported with discordjs-button-pagination"
    );
  if (buttonList.length !== 3) throw new Error("Need three buttons.");

  let page = startingId;
  
  var row = new MessageActionRow().addComponents(buttonList);
  var singleRow = new MessageActionRow().addComponents(buttonList[1]);
  
  if(extraButtons[page].customId.split("|")[1] != "None"){
      row.addComponents(extraButtons[page]);
      singleRow.addComponents(extraButtons[page]);
  }
  
  var curPage = "";
  if(pages.length == 1){
	curPage = await msg.reply({
	  embeds: [pages[page].setFooter(`Page ${page + 1} / ${pages.length}`)],
	  components: [singleRow],
	  allowedMentions: { repliedUser: false },
	  fetchReply: true,
	});
  }else{
    curPage = await msg.reply({
      embeds: [pages[page].setFooter(`Page ${page + 1} / ${pages.length}`)],
      components: [row],
	  allowedMentions: { repliedUser: false },
	  fetchReply: true,
    });

    const filter = (i) =>
      i.customId === buttonList[0].customId ||
      i.customId === buttonList[2].customId ||
      i.customId === extraButtons[page].customId &&
	  i.member.user.id === msg.member.user.id;

    const collector = await curPage.createMessageComponentCollector({
      filter,
      time: timeout,
    });

    collector.on("collect", async (i) => {
      switch (i.customId) {
        case buttonList[0].customId:
          page = page > 0 ? --page : pages.length - 1;
          break;
        case buttonList[2].customId:
          page = page + 1 < pages.length ? ++page : 0;
          break;
        case extraButtons[page].customId:
          page = parseInt(extraButtons[page].customId.split("|")[1]);
          break;
        default:
          break;
      }
      buttonList[1] = new MessageButton()
			.setCustomId(msg.member.user.id + '|captures favorite ' + pages[page].title.trim())
			.setLabel('Favorite')
			.setStyle('SUCCESS');
      row = new MessageActionRow().addComponents(buttonList);
      if(extraButtons[page].customId.split("|")[1] != "None"){
          row.addComponents(extraButtons[page]);
      }
      await i.deferUpdate();
      await i.editReply({
        embeds: [pages[page].setFooter(`Page ${page + 1} / ${pages.length}`)],
        components: [row],
      });
      collector.resetTimer();
    });

    collector.on("end", () => {
      if (!curPage.deleted) {
        const row = new MessageActionRow().addComponents(
          buttonList[0].setDisabled(true),
          buttonList[1].setDisabled(true),
          buttonList[2].setDisabled(true)
        );
        curPage.edit({
          embeds: [pages[page].setFooter(`Page ${page + 1} / ${pages.length}`)],
          components: [row],
        });
      }
    });

  }

  return curPage;
};

const paginationNight = async (msg, pages, buttonList, startingId, timeout = 120000) => {
  if (!msg && !msg.channel) throw new Error("Channel is inaccessible.");
  if (!pages) throw new Error("Pages are not given.");
  if (!buttonList) throw new Error("Buttons are not given.");
  if (buttonList[0].style === "LINK" || buttonList[1].style === "LINK")
    throw new Error(
      "Link buttons are not supported with discordjs-button-pagination"
    );
  if (buttonList.length !== 2) throw new Error("Need two buttons.");

  let page = startingId;
  
  var row = new MessageActionRow().addComponents(buttonList);
  
  var curPage = "";
  if(pages.length == 1){
	curPage = await msg.reply({
	  content: pages[page] + `\nResult ${page + 1} / ${pages.length}`,
	  allowedMentions: { repliedUser: false },
	  fetchReply: true,
	});
  }else{
    curPage = await msg.reply({
      content: pages[page] + `\nResult ${page + 1} / ${pages.length}`,
      components: [row],
	  allowedMentions: { repliedUser: false },
	  fetchReply: true,
    });

    const filter = (i) =>
      i.customId === buttonList[0].customId ||
      i.customId === buttonList[1].customId &&
	  i.member.user.id === msg.member.user.id;

    const collector = await curPage.createMessageComponentCollector({
      filter,
      time: timeout,
    });

    collector.on("collect", async (i) => {
      switch (i.customId) {
        case buttonList[0].customId:
          page = page > 0 ? --page : pages.length - 1;
          break;
        case buttonList[1].customId:
          page = page + 1 < pages.length ? ++page : 0;
          break;
        default:
          break;
      }
      await i.deferUpdate();
      await i.editReply({
        content: pages[page] + `\nResult ${page + 1} / ${pages.length}`,
        components: [row],
      });
      collector.resetTimer();
    });

    collector.on("end", () => {
      if (!curPage.deleted) {
        const row = new MessageActionRow().addComponents(
          buttonList[0].setDisabled(true),
          buttonList[1].setDisabled(true)
        );
        curPage.edit({
          content: pages[page] + `\nResult ${page + 1} / ${pages.length}`,
          components: [row],
        });
      }
    });

  }

  return curPage;
};

module.exports = { paginationEmbed, paginationEmbedAlt, paginationNight };